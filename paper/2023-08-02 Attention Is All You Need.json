{
    "title-area": "Attention Is All You Need",
    "authors-area": "Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Łukasz Kaiser",
    "institutes-area": "Google Brain, Google Research, University of Toronto",
    "publication": "arxiv",
    "publish_time": "2023-08-02",
    "introduction_processed": "Recurrent neural networks, long short-term memory and gated recurrent neural networks in particular, have been firmly established as state of the art approaches in sequence modeling and transduction problems such as language modeling and machine translation. Numerous efforts have since continued to push the boundaries of recurrent language models and encoder-decoder architectures. Recurrent models typically factor computation along the symbol positions of the input and output sequences. Aligning the positions to steps in computation time, they generate a sequence of hidden states $h_t$, as a function of the previous hidden state $h_{t-1}$ and the input for position $t$. This inherently sequential nature precludes parallelization within training examples, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples. Recent work has achieved significant improvements in computational efficiency through factorization tricks and conditional computation, while also improving model performance in case of the latter. The fundamental constraint of sequential computation, however, remains. Attention mechanisms have become an integral part of compelling sequence modeling and transduction models in various tasks, allowing modeling of dependencies without regard to their distance in the input or output sequences. In all but a few cases, however, such attention mechanisms are used in conjunction with a recurrent network. In this work we propose the Transformer, a model architecture eschewing recurrence and instead relying entirely on an attention mechanism to draw global dependencies between input and output. The Transformer allows for significantly more parallelization and can reach a new state of the art in translation quality after being trained for as little as twelve hours on eight P100 GPUs.",
    "abstract_processed": "The dominant sequence transduction models are based on complex recurrent or convolutional neural networks that include an encoder and a decoder. The best performing models also connect the encoder and decoder through an attention mechanism. We propose a new simple network architecture, the Transformer, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely. Experiments on two machine translation tasks show these models to be superior in quality while being more parallelizable and requiring significantly less time to train. Our model achieves $28.4$ BLEU on the WMT $2014$ English-to-German translation task, improving over the existing best results, including ensembles, by over $2$ BLEU. On the WMT $2014$ English-to-French translation task, our model establishes a new single-model state-of-the-art BLEU score of $41.8$ after training for $3.5$ days on eight GPUs, a small fraction of the training costs of the best models from the literature. We show that the Transformer generalizes well to other tasks by applying it successfully to English constituency parsing both with large and limited training data.",
    "keywords-area": "",
    "sections": [
        {
            "flag": true,
            "id": "d2d6bf28-9c68-4b74-be87-7a7415921680",
            "title": "Background",
            "texts": "The goal of reducing sequential computation also forms the foundation of the Extended Neural GPU\n[16], ByteNet [18] and ConvS2S [9], all of which use convolutional neural networks as basic building\nblock, computing hidden representations in parallel for all input and output positions. In these models,\nthe number of operations required to relate signals from two arbitrary input or output positions grows\nin the distance between positions, linearly for ConvS2S and logarithmically for ByteNet. This makes\nit more difficult to learn dependencies between distant positions [12]. In the Transformer this is\nreduced to a constant number of operations, albeit at the cost of reduced effective resolution due\nto averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as\ndescribed in section 3.2.\nSelf-attention, sometimes called intra-attention is an attention mechanism relating different positions\nof a single sequence in order to compute a representation of the sequence. Self-attention has been\nused successfully in a variety of tasks including reading comprehension, abstractive summarization,\ntextual entailment and learning task-independent sentence representations [4, 27, 28, 22].\nEnd-to-end memory networks are based on a recurrent attention mechanism instead of sequencealigned recurrence and have been shown to perform well on simple-language question answering and\nlanguage modeling tasks [34].\nTo the best of our knowledge, however, the Transformer is the first transduction model relying\nentirely on self-attention to compute representations of its input and output without using sequencealigned RNNs or convolution. In the following sections, we will describe the Transformer, motivate\nself-attention and discuss its advantages over models such as [17, 18] and [9]",
            "sections": []
        },
        {
            "flag": true,
            "id": "12ec6ed0-f7ff-403a-b61c-73174b2e81a7",
            "title": "Model Architecture",
            "texts": "Most competitive neural sequence transduction models have an encoder-decoder structure [5, 2, 35].\nHere, the encoder maps an input sequence of symbol representations (x1, ..., xn) to a sequence\nof continuous representations z = (z1, ..., zn). Given z, the decoder then generates an output\nsequence (y1, ..., ym) of symbols one element at a time. At each step the model is auto-regressive\n[10], consuming the previously generated symbols as additional input when generating the next.\n",
            "sections": [
                {
                    "flag": true,
                    "id": "fc8a6d85-403f-4551-99f8-81b756e9bd5d",
                    "title": "Encoder and Decoder Stacks",
                    "texts": "Encoder: The encoder is composed of a stack of N = 6 identical layers. Each layer has two\nsub-layers. The first is a multi-head self-attention mechanism, and the second is a simple, positionwise fully connected feed-forward network. We employ a residual connection [11] around each of\nthe two sub-layers, followed by layer normalization [1]. That is, the output of each sub-layer is\nLayerNorm(x + Sublayer(x)), where Sublayer(x) is the function implemented by the sub-layer\nitself. To facilitate these residual connections, all sub-layers in the model, as well as the embedding\nlayers, produce outputs of dimension dmodel = 512.\nDecoder: The decoder is also composed of a stack of N = 6 identical layers. In addition to the two\nsub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head\nattention over the output of the encoder stack. Similar to the encoder, we employ residual connections\naround each of the sub-layers, followed by layer normalization. We also modify the self-attention\nsub-layer in the decoder stack to prevent positions from attending to subsequent positions. This\nmasking, combined with fact that the output embeddings are offset by one position, ensures that the\npredictions for position i can depend only on the known outputs at positions less than i.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "b3e608c0-fb3d-49f2-a553-4e93da694334",
                    "title": "Attention",
                    "texts": "An attention function can be described as mapping a query and a set of key-value pairs to an output,\nwhere the query, keys, values, and output are all vectors. The output is computed as a weighted sum\nof the values, where the weight assigned to each value is computed by a compatibility function of the\nquery with the corresponding key.",
                    "sections": [
                        {
                            "flag": true,
                            "id": "dfd8bf32-e2b8-45bf-867e-6701c9d1295e",
                            "title": "Scaled Dot-Product Attention",
                            "texts": "We call our particular attention \"Scaled Dot-Product Attention\" (Figure 2). The input consists of\nqueries and keys of dimension dk, and values of dimension dv. We compute the dot products of the\nquery with all keys, divide each by √dk, and apply a softmax function to obtain the weights on the\nvalues.\nIn practice, we compute the attention function on a set of queries simultaneously, packed together\ninto a matrix Q. The keys and values are also packed together into matrices K and V . We compute\nthe matrix of outputs as:\nAttention(Q, K, V ) = softmax(QK √dkT )V (1)\nThe two most commonly used attention functions are additive attention [2], and dot-product (multiplicative) attention. Dot-product attention is identical to our algorithm, except for the scaling factor\nof √1dk . Additive attention computes the compatibility function using a feed-forward network with\na single hidden layer. While the two are similar in theoretical complexity, dot-product attention is\nmuch faster and more space-efficient in practice, since it can be implemented using highly optimized\nmatrix multiplication code.\nWhile for small values of dk the two mechanisms perform similarly, additive attention outperforms\ndot product attention without scaling for larger values of dk [3]. We suspect that for large values of\ndk, the dot products grow large in magnitude, pushing the softmax function into regions where it has\nextremely small gradients 4. To counteract this effect, we scale the dot products by √1dk .",
                            "sections": []
                        },
                        {
                            "flag": true,
                            "id": "d253c4b2-38ff-4706-b2b3-62544fe834fe",
                            "title": "Multi-Head Attention",
                            "texts": "Instead of performing a single attention function with dmodel-dimensional keys, values and queries,\nwe found it beneficial to linearly project the queries, keys and values h times with different, learned\nlinear projections to dk, dk and dv dimensions, respectively. On each of these projected versions of\nqueries, keys and values we then perform the attention function in parallel, yielding dv-dimensional\noutput values. These are concatenated and once again projected, resulting in the final values, as\ndepicted in Figure 2.\nMulti-head attention allows the model to jointly attend to information from different representation\nsubspaces at different positions. With a single attention head, averaging inhibits this.\nMultiHead(Q, K, V ) = Concat(head1, ..., headh)WO\nwhere headi = Attention(QWiQ, KWiK, V WiV )\nWhere the projections are parameter matrices WiQ ∈ Rdmodel×dk, WiK ∈ Rdmodel×dk, WiV ∈ Rdmodel×dv\nand WO ∈ Rhdv×dmodel.\nIn this work we employ h = 8 parallel attention layers, or heads. For each of these we use\ndk = dv = dmodel/h = 64. Due to the reduced dimension of each head, the total computational cost\nis similar to that of single-head attention with full dimensionality.",
                            "sections": []
                        },
                        {
                            "flag": true,
                            "id": "150706c0-4671-40c0-9ac7-40d6f6ff6bd9",
                            "title": "Applications of Attention in our Model",
                            "texts": "The Transformer uses multi-head attention in three different ways:\n• In \"encoder-decoder attention\" layers, the queries come from the previous decoder layer,\nand the memory keys and values come from the output of the encoder. This allows every\nposition in the decoder to attend over all positions in the input sequence. This mimics the\ntypical encoder-decoder attention mechanisms in sequence-to-sequence models such as\n[38, 2, 9].\n• The encoder contains self-attention layers. In a self-attention layer all of the keys, values\nand queries come from the same place, in this case, the output of the previous layer in the\nencoder. Each position in the encoder can attend to all positions in the previous layer of the\nencoder.\n• Similarly, self-attention layers in the decoder allow each position in the decoder to attend to\nall positions in the decoder up to and including that position. We need to prevent leftward\ninformation flow in the decoder to preserve the auto-regressive property. We implement this\ninside of scaled dot-product attention by masking out (setting to −∞) all values in the input\nof the softmax which correspond to illegal connections. See Figure 2.",
                            "sections": []
                        }
                    ]
                },
                {
                    "flag": true,
                    "id": "6ae9eedf-e5fa-4161-8adf-a0830833084d",
                    "title": "Position-wise Feed-Forward Networks",
                    "texts": "In addition to attention sub-layers, each of the layers in our encoder and decoder contains a fully\nconnected feed-forward network, which is applied to each position separately and identically. This\nconsists of two linear transformations with a ReLU activation in between.\nFFN(x) = max(0, xW1 + b1)W2 + b2 (2)\nWhile the linear transformations are the same across different positions, they use different parameters\nfrom layer to layer. Another way of describing this is as two convolutions with kernel size 1.\nThe dimensionality of input and output is dmodel = 512, and the inner-layer has dimensionality\ndff = 2048.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "01ef2da7-d53f-435a-89ec-5626cfa7adb6",
                    "title": "Embeddings and Softmax",
                    "texts": "Similarly to other sequence transduction models, we use learned embeddings to convert the input\ntokens and output tokens to vectors of dimension dmodel. We also use the usual learned linear transformation and softmax function to convert the decoder output to predicted next-token probabilities. In\nour model, we share the same weight matrix between the two embedding layers and the pre-softmax\nlinear transformation, similar to [30]. In the embedding layers, we multiply those weights by √dmodel.\n",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "499cfaf8-be29-409d-a9d4-0ed0010ccb24",
                    "title": "Positional Encoding",
                    "texts": "Since our model contains no recurrence and no convolution, in order for the model to make use of the\norder of the sequence, we must inject some information about the relative or absolute position of the\ntokens in the sequence. To this end, we add \"positional encodings\" to the input embeddings at the\nbottoms of the encoder and decoder stacks. The positional encodings have the same dimension dmodel\nas the embeddings, so that the two can be summed. There are many choices of positional encodings,\nlearned and fixed [9].\nIn this work, we use sine and cosine functions of different frequencies:\nP E(pos,2i) = sin(pos/100002i/dmodel)\nP E(pos,2i+1) = cos(pos/100002i/dmodel)\nwhere pos is the position and i is the dimension. That is, each dimension of the positional encoding\ncorresponds to a sinusoid. The wavelengths form a geometric progression from 2π to 10000 · 2π. We\nchose this function because we hypothesized it would allow the model to easily learn to attend by\nrelative positions, since for any fixed offset k, P Epos+k can be represented as a linear function of\nP E\npos.\nWe also experimented with using learned positional embeddings [9] instead, and found that the two\nversions produced nearly identical results (see Table 3 row (E)). We chose the sinusoidal version\nbecause it may allow the model to extrapolate to sequence lengths longer than the ones encountered\nduring training",
                    "sections": []
                }
            ]
        },
        {
            "flag": true,
            "id": "9a320189-5397-4731-b125-0832b9962cd2",
            "title": "Why Self-Attention",
            "texts": "In this section we compare various aspects of self-attention layers to the recurrent and convolutional layers commonly used for mapping one variable-length sequence of symbol representations\n(x1, ..., xn) to another sequence of equal length (z1, ..., zn), with xi, zi ∈ Rd, such as a hidden\nlayer in a typical sequence transduction encoder or decoder. Motivating our use of self-attention we\nconsider three desiderata.\nOne is the total computational complexity per layer. Another is the amount of computation that can\nbe parallelized, as measured by the minimum number of sequential operations required.\nThe third is the path length between long-range dependencies in the network. Learning long-range\ndependencies is a key challenge in many sequence transduction tasks. One key factor affecting the\nability to learn such dependencies is the length of the paths forward and backward signals have to\ntraverse in the network. The shorter these paths between any combination of positions in the input\nand output sequences, the easier it is to learn long-range dependencies [12]. Hence we also compare\nthe maximum path length between any two input and output positions in networks composed of the\ndifferent layer types.\nAs noted in Table 1, a self-attention layer connects all positions with a constant number of sequentially\nexecuted operations, whereas a recurrent layer requires O(n) sequential operations. In terms of\ncomputational complexity, self-attention layers are faster than recurrent layers when the sequence\n",
            "sections": []
        },
        {
            "flag": true,
            "id": "651fe7c7-d25e-4ad9-87db-7136b645ff5c",
            "title": "Training",
            "texts": "This section describes the training regime for our models.",
            "sections": [
                {
                    "flag": true,
                    "id": "2bcc9650-c262-4e90-918a-e45846ba47c2",
                    "title": "Training Data and Batching",
                    "texts": "We trained on the standard WMT 2014 English-German dataset consisting of about 4.5 million\nsentence pairs. Sentences were encoded using byte-pair encoding [3], which has a shared sourcetarget vocabulary of about 37000 tokens. For English-French, we used the significantly larger WMT\n2014 English-French dataset consisting of 36M sentences and split tokens into a 32000 word-piece\nvocabulary [38]. Sentence pairs were batched together by approximate sequence length. Each training\nbatch contained a set of sentence pairs containing approximately 25000 source tokens and 25000\ntarget tokens.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "ce1fdeda-e1b8-45ec-a0ae-084e29586e7c",
                    "title": "Hardware and Schedule",
                    "texts": "We trained our models on one machine with 8 NVIDIA P100 GPUs. For our base models using\nthe hyperparameters described throughout the paper, each training step took about 0.4 seconds. We\ntrained the base models for a total of 100,000 steps or 12 hours. For our big models,(described on the\nbottom line of table 3), step time was 1.0 seconds. The big models were trained for 300,000 steps\n(3.5 days).",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "3a8dc153-4a94-40f8-af6c-c7e70c29c246",
                    "title": "Optimizer",
                    "texts": "We used the Adam optimizer [20] with β1 = 0.9, β2 = 0.98 and ϵ = 10−9. We varied the learning\nrate over the course of training, according to the formula:\nlrate = d−0.5\nmodel · min(step_num−0.5, step_num · warmup_steps−1.5) (3)\nThis corresponds to increasing the learning rate linearly for the first warmup_steps training steps,\nand decreasing it thereafter proportionally to the inverse square root of the step number. We used\nwarmup_steps = 4000.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "5314ec67-89bf-4764-a62c-b686af852b4a",
                    "title": "Regularization",
                    "texts": "We employ three types of regularization during training:\nResidual Dropout We apply dropout [33] to the output of each sub-layer, before it is added to the\nsub-layer input and normalized. In addition, we apply dropout to the sums of the embeddings and the\npositional encodings in both the encoder and decoder stacks. For the base model, we use a rate of\nPdrop = 0.1.\nLabel Smoothing During training, we employed label smoothing of value ϵls = 0.1 [36]. This\nhurts perplexity, as the model learns to be more unsure, but improves accuracy and BLEU score.",
                    "sections": []
                }
            ]
        },
        {
            "flag": true,
            "id": "54f21048-6d63-4411-b3ea-7cc3b8d0fc40",
            "title": "Results",
            "texts": "",
            "sections": [
                {
                    "flag": true,
                    "id": "376910db-02e6-4c63-94b7-4d99e5a536fa",
                    "title": "Machine Translation",
                    "texts": "On the WMT 2014 English-to-German translation task, the big transformer model (Transformer (big)\nin Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0\nBLEU, establishing a new state-of-the-art BLEU score of 28.4. The configuration of this model is\nlisted in the bottom line of Table 3. Training took 3.5 days on 8 P100 GPUs. Even our base model\nsurpasses all previously published models and ensembles, at a fraction of the training cost of any of\nthe competitive models.\nOn the WMT 2014 English-to-French translation task, our big model achieves a BLEU score of 41.0,\noutperforming all of the previously published single models, at less than 1/4 the training cost of the\nprevious state-of-the-art model. The Transformer (big) model trained for English-to-French used\ndropout rate Pdrop = 0.1, instead of 0.3.\nFor the base models, we used a single model obtained by averaging the last 5 checkpoints, which\nwere written at 10-minute intervals. For the big models, we averaged the last 20 checkpoints. We\nused beam search with a beam size of 4 and length penalty α = 0.6 [38]. These hyperparameters\nwere chosen after experimentation on the development set. We set the maximum output length during\ninference to input length + 50, but terminate early when possible [38].\nTable 2 summarizes our results and compares our translation quality and training costs to other model\narchitectures from the literature. We estimate the number of floating point operations used to train a\nmodel by multiplying the training time, the number of GPUs used, and an estimate of the sustained\nsingle-precision floating-point capacity of each GPU 5.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "7a9b47e2-4e03-47fc-8aec-492940ae91ab",
                    "title": "Model Variations",
                    "texts": "To evaluate the importance of different components of the Transformer, we varied our base model\nin different ways, measuring the change in performance on English-to-German translation on the\ndevelopment set, newstest2013. We used beam search as described in the previous section, but no\ncheckpoint averaging. We present these results in Table 3.\nIn Table 3 rows (A), we vary the number of attention heads and the attention key and value dimensions,\nkeeping the amount of computation constant, as described in Section 3.2.2. While single-head\nattention is 0.9 BLEU worse than the best setting, quality also drops off with too many heads.\nIn Table 3 rows (B), we observe that reducing the attention key size dk hurts model quality. This\nsuggests that determining compatibility is not easy and that a more sophisticated compatibility\nfunction than dot product may be beneficial. We further observe in rows (C) and (D) that, as expected,\nbigger models are better, and dropout is very helpful in avoiding over-fitting. In row (E) we replace our\nsinusoidal positional encoding with learned positional embeddings [9], and observe nearly identical\nresults to the base model.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "2e6f7c77-ac38-4204-a7fe-9d0e97c3f841",
                    "title": "English Constituency Parsing",
                    "texts": "To evaluate if the Transformer can generalize to other tasks we performed experiments on English\nconstituency parsing. This task presents specific challenges: the output is subject to strong structural\nconstraints and is significantly longer than the input. Furthermore, RNN sequence-to-sequence\nmodels have not been able to attain state-of-the-art results in small-data regimes [37].\nWe trained a 4-layer transformer with dmodel = 1024 on the Wall Street Journal (WSJ) portion of the\nPenn Treebank [25], about 40K training sentences. We also trained it in a semi-supervised setting,\nusing the larger high-confidence and BerkleyParser corpora from with approximately 17M sentences\n[37]. We used a vocabulary of 16K tokens for the WSJ only setting and a vocabulary of 32K tokens\nfor the semi-supervised setting.\nWe performed only a small number of experiments to select the dropout, both attention and residual\n(section 5.4), learning rates and beam size on the Section 22 development set, all other parameters\nremained unchanged from the English-to-German base translation model. During inference, we\nincreased the maximum output length to input length + 300. We used a beam size of 21 and α = 0.3\nfor both WSJ only and the semi-supervised setting.\nOur results in Table 4 show that despite the lack of task-specific tuning our model performs surprisingly well, yielding better results than all previously reported models with the exception of the\nRecurrent Neural Network Grammar [8].\nIn contrast to RNN sequence-to-sequence models [37], the Transformer outperforms the BerkeleyParser [29] even when training only on the WSJ training set of 40K sentences.",
                    "sections": []
                }
            ]
        },
        {
            "flag": true,
            "id": "7feb6a67-87ba-4c5a-90bb-b944ba12823c",
            "title": "Conclusion",
            "texts": "In this work, we presented the Transformer, the first sequence transduction model based entirely on\nattention, replacing the recurrent layers most commonly used in encoder-decoder architectures with\nmulti-headed self-attention.\nFor translation tasks, the Transformer can be trained significantly faster than architectures based\non recurrent or convolutional layers. On both WMT 2014 English-to-German and WMT 2014\nEnglish-to-French translation tasks, we achieve a new state of the art. In the former task our best\nmodel outperforms even all previously reported ensembles.\nWe are excited about the future of attention-based models and plan to apply them to other tasks. We\nplan to extend the Transformer to problems involving input and output modalities other than text and\nto investigate local, restricted attention mechanisms to efficiently handle large inputs and outputs\nsuch as images, audio and video. Making generation less sequential is another research goals of ours.\nThe code we used to train and evaluate our models is available at https://github.com/\ntensorflow/tensor2tensor.\nAcknowledgements We are grateful to Nal Kalchbrenner and Stephan Gouws for their fruitful\ncomments, corrections and inspiration.",
            "sections": []
        }
    ],
    "sections_processed": [
        {
            "flag": true,
            "id": "d2d6bf28-9c68-4b74-be87-7a7415921680",
            "title": "Background",
            "texts": "The goal of reducing sequential computation also forms the foundation of the Extended Neural GPU (EN-GPU) [16], ByteNet [18], and ConvS2S, all of which use convolutional neural networks as a basic building block, computing hidden representations in parallel for all input and output positions. In these models, the number of operations required to relate signals from two arbitrary input or output positions grows with the distance between positions, linearly for ConvS2S and logarithmically for ByteNet. This makes it more difficult to learn dependencies between distant positions. In the Transformer, this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as described in section 3.2.\n\nSelf-attention, sometimes called intra-attention, is an attention mechanism relating different positions of a single sequence in order to compute a representation of the sequence. Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, textual entailment, and learning task-independent sentence representations.\n\nEnd-to-end memory networks are based on a recurrent attention mechanism instead of sequence-aligned recurrence and have been shown to perform well on simple-language question answering and language modeling tasks.\n\nTo the best of our knowledge, however, the Transformer is the first transduction model relying entirely on self-attention to compute representations of its input and output without using sequence-aligned RNNs or convolution. In the following sections, we will describe the Transformer, motivate self-attention and discuss its advantages over models such as ByteNet and ConvS2S.",
            "sections": []
        },
        {
            "flag": true,
            "id": "12ec6ed0-f7ff-403a-b61c-73174b2e81a7",
            "title": "Model Architecture",
            "texts": "Most competitive neural sequence transduction models have an encoder-decoder structure. Here, the encoder maps an input sequence of symbol representations $(x_1, ..., x_n)$ to a sequence of continuous representations $z = (z_1, ..., z_n)$. Given $z$, the decoder then generates an output sequence $(y_1, ..., y_m)$ of symbols one element at a time. At each step the model is auto-regressive, consuming the previously generated symbols as additional input when generating the next.",
            "sections": [
                {
                    "flag": true,
                    "id": "fc8a6d85-403f-4551-99f8-81b756e9bd5d",
                    "title": "Encoder and Decoder Stacks",
                    "texts": "Encoder: The encoder is composed of a stack of $N = 6$ identical layers. Each layer has two sub-layers. The first is a multi-head self-attention mechanism, and the second is a simple, positionwise fully connected feed-forward network. We employ a residual connection around each of the two sub-layers, followed by layer normalization. That is, the output of each sub-layer is $\\text{LayerNorm}(x + \\text{Sublayer}(x))$, where $\\text{Sublayer}(x)$ is the function implemented by the sub-layer itself. To facilitate these residual connections, all sub-layers in the model, as well as the embedding layers, produce outputs of dimension $d_{\\text{model}} = 512$. \nDecoder: The decoder is also composed of a stack of $N = 6$ identical layers. In addition to the two sub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head attention over the output of the encoder stack. Similar to the encoder, we employ residual connections around each of the sub-layers, followed by layer normalization. We also modify the self-attention sub-layer in the decoder stack to prevent positions from attending to subsequent positions. This masking, combined with fact that the output embeddings are offset by one position, ensures that the predictions for position $i$ can depend only on the known outputs at positions less than $i$.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "b3e608c0-fb3d-49f2-a553-4e93da694334",
                    "title": "Attention",
                    "texts": "An attention function can be described as mapping a query and a set of key-value pairs to an output, where the query, keys, values, and output are all vectors. The output is computed as a weighted sum of the values, where the weight assigned to each value is computed by a compatibility function of the query with the corresponding key.",
                    "sections": [
                        {
                            "flag": true,
                            "id": "dfd8bf32-e2b8-45bf-867e-6701c9d1295e",
                            "title": "Scaled Dot-Product Attention",
                            "texts": "We call our particular attention 'Scaled Dot-Product Attention' (Figure 2).\nThe input consists of queries and keys of dimension $d_k$, and values of dimension $d_v$. We compute the dot products of the query with all keys, divide each by $\\\\sqrt{d_k}$, and apply a softmax function to obtain the weights on the values.\nIn practice, we compute the attention function on a set of queries simultaneously, packed together into a matrix $Q$. The keys and values are also packed together into matrices $K$ and $V$. We compute the matrix of outputs as:\n$$\\text{Attention}(Q, K, V) = \\text{softmax}(\\frac{QK}{\\sqrt{d_k}})V$$\nThe two most commonly used attention functions are additive attention, and dot-product (multiplicative) attention. Dot-product attention is identical to our algorithm, except for the scaling factor of $\\\\sqrt{1/d_k}$. Additive attention computes the compatibility function using a feed-forward network with a single hidden layer. While the two are similar in theoretical complexity, dot-product attention is much faster and more space-efficient in practice, since it can be implemented using highly optimized matrix multiplication code.\nWhile for small values of $d_k$ the two mechanisms perform similarly, additive attention outperforms dot product attention without scaling for larger values of $d_k$. We suspect that for large values of $d_k$, the dot products grow large in magnitude, pushing the softmax function into regions where it has extremely small gradients. To counteract this effect, we scale the dot products by $\\\\sqrt{1/d_k}$.",
                            "sections": []
                        },
                        {
                            "flag": true,
                            "id": "d253c4b2-38ff-4706-b2b3-62544fe834fe",
                            "title": "Multi-Head Attention",
                            "texts": "Instead of performing a single attention function with $d_{\\text{model}}$-dimensional keys, values and queries, we found it beneficial to linearly project the queries, keys and values $h$ times with different, learned linear projections to $d_k$, $d_k$ and $d_v$ dimensions, respectively. On each of these projected versions of queries, keys and values we then perform the attention function in parallel, yielding $d_v$-dimensional output values. These are concatenated and once again projected, resulting in the final values, as depicted in Figure 2.\nMulti-head attention allows the model to jointly attend to information from different representation subspaces at different positions. With a single attention head, averaging inhibits this.\n$MultiHead(Q, K, V) = \\text{Concat}(head_1, ..., head_h)WO$ where $head_i = \\text{Attention}(QW_i^Q, KW_i^K, VW_i^V)$\nWhere the projections are parameter matrices $W_i^Q \\in \\mathbb{R}^{d_{\\text{model}} \\times d_k}$, $W_i^K \\in \\mathbb{R}^{d_{\\text{model}} \\times d_k}$, $W_i^V \\in \\mathbb{R}^{d_{\\text{model}} \\times d_v}$ and $W_O \\in \\mathbb{R}^{h \\times d_v \\times d_{\\text{model}}}$. In this work we employ $h = 8$ parallel attention layers, or heads. For each of these we use $d_k = d_v = d_{\\text{model}}/h = 64$. Due to the reduced dimension of each head, the total computational cost is similar to that of single-head attention with full dimensionality.",
                            "sections": []
                        },
                        {
                            "flag": true,
                            "id": "150706c0-4671-40c0-9ac7-40d6f6ff6bd9",
                            "title": "Applications of Attention in our Model",
                            "texts": "The Transformer uses multi-head attention in three different ways:\n• In 'encoder-decoder attention' layers, the queries come from the previous decoder layer, and the memory keys and values come from the output of the encoder. This allows every position in the decoder to attend over all positions in the input sequence. This mimics the typical encoder-decoder attention mechanisms in sequence-to-sequence models such as $[38, 2, 9]$. \n• The encoder contains self-attention layers. In a self-attention layer all of the keys, values and queries come from the same place, in this case, the output of the previous layer in the encoder. Each position in the encoder can attend to all positions in the previous layer of the encoder. \n• Similarly, self-attention layers in the decoder allow each position in the decoder to attend to all positions in the decoder up to and including that position. We need to prevent leftward information flow in the decoder to preserve the auto-regressive property. We implement this inside of scaled dot-product attention by masking out (setting to $-∞$) all values in the input of the softmax which correspond to illegal connections. See Figure 2.",
                            "sections": []
                        }
                    ]
                },
                {
                    "flag": true,
                    "id": "6ae9eedf-e5fa-4161-8adf-a0830833084d",
                    "title": "Position-wise Feed-Forward Networks",
                    "texts": "In addition to attention sub-layers, each of the layers in our encoder and decoder contains a fully connected feed-forward network, which is applied to each position separately and identically. This consists of two linear transformations with a ReLU activation in between.\n$$FFN(x) = \\max(0, xW1 + b1)W2 + b2$$\nWhile the linear transformations are the same across different positions, they use different parameters from layer to layer. Another way of describing this is as two convolutions with kernel size 1. The dimensionality of input and output is $d_{\\text{model}} = 512$, and the inner-layer has dimensionality $d_{\\text{ff}} = 2048$.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "01ef2da7-d53f-435a-89ec-5626cfa7adb6",
                    "title": "Embeddings and Softmax",
                    "texts": "Similarly to other sequence transduction models, we use learned embeddings to convert the input tokens and output tokens to vectors of dimension $d_{\\text{model}}$. We also use the usual learned linear transformation and softmax function to convert the decoder output to predicted next-token probabilities. In our model, we share the same weight matrix between the two embedding layers and the pre-softmax linear transformation, similar to [30]. In the embedding layers, we multiply those weights by $\\\\sqrt{d_{\\text{model}}}$.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "499cfaf8-be29-409d-a9d4-0ed0010ccb24",
                    "title": "Positional Encoding",
                    "texts": "Since our model contains no recurrence and no convolution, in order for the model to make use of the order of the sequence, we must inject some information about the relative or absolute position of the tokens in the sequence.\nTo this end, we add 'positional encodings' to the input embeddings at the bottoms of the encoder and decoder stacks. The positional encodings have the same dimension $d_{\\text{model}}$ as the embeddings, so that the two can be summed. There are many choices of positional encodings, learned and fixed.\nIn this work, we use sine and cosine functions of different frequencies:\n$PE(pos,2i) = \\sin(pos / 10000^{2i} / d_{\\text{model}})$\n$PE(pos,2i+1) = \\cos(pos / 10000^{2i} / d_{\\text{model}})$\nwhere pos is the position and i is the dimension. That is, each dimension of the positional encoding corresponds to a sinusoid. The wavelengths form a geometric progression from $2\\pi$ to $10000 \\cdot 2\\pi$. We chose this function because we hypothesized it would allow the model to easily learn to attend by relative positions, since for any fixed offset k, $PE_{pos+k}$ can be represented as a linear function of $PE_{pos}$.\nWe also experimented with using learned positional embeddings instead, and found that the two versions produced nearly identical results. We chose the sinusoidal version because it may allow the model to extrapolate to sequence lengths longer than the ones encountered during training.",
                    "sections": []
                }
            ]
        },
        {
            "flag": true,
            "id": "9a320189-5397-4731-b125-0832b9962cd2",
            "title": "Why Self-Attention",
            "texts": "In this section we compare various aspects of self-attention layers to the recurrent and convolutional layers commonly used for mapping one variable-length sequence of symbol representations $(x_1, ..., x_n)$ to another sequence of equal length $(z_1, ..., z_n)$, with $x_i, z_i \\in \\mathbb{R}^d$, such as a hidden layer in a typical sequence transduction encoder or decoder. Motivating our use of self-attention we consider three desiderata. One is the total computational complexity per layer. Another is the amount of computation that can be parallelized, as measured by the minimum number of sequential operations required. The third is the path length between long-range dependencies in the network. Learning long-range dependencies is a key challenge in many sequence transduction tasks. One key factor affecting the ability to learn such dependencies is the length of the paths forward and backward signals have to traverse in the network. The shorter these paths between any combination of positions in the input and output sequences, the easier it is to learn long-range dependencies. Hence we also compare the maximum path length between any two input and output positions in networks composed of the different layer types. As noted in Table 1, a self-attention layer connects all positions with a constant number of sequentially executed operations, whereas a recurrent layer requires $O(n)$ sequential operations. In terms of computational complexity, self-attention layers are faster than recurrent layers when the sequence",
            "sections": []
        },
        {
            "flag": true,
            "id": "651fe7c7-d25e-4ad9-87db-7136b645ff5c",
            "title": "Training",
            "texts": "This section describes the training regime for our models.",
            "sections": [
                {
                    "flag": true,
                    "id": "2bcc9650-c262-4e90-918a-e45846ba47c2",
                    "title": "Training Data and Batching",
                    "texts": "We trained on the standard WMT 2014 English-German dataset consisting of about 4.5 million sentence pairs. Sentences were encoded using byte-pair encoding ($[3]$), which has a shared source-target vocabulary of about 37000 tokens.\n\nFor English-French, we used the significantly larger WMT 2014 English-French dataset consisting of 36M sentences and split tokens into a 32000 word-piece vocabulary ($[38]$). Sentence pairs were batched together by approximate sequence length. Each training batch contained a set of sentence pairs containing approximately 25000 source tokens and 25000 target tokens.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "ce1fdeda-e1b8-45ec-a0ae-084e29586e7c",
                    "title": "Hardware and Schedule",
                    "texts": "We trained our models on one machine with 8 NVIDIA P100 GPUs. For our base models using the hyperparameters described throughout the paper, each training step took about $0.4$ seconds. We trained the base models for a total of $100,000$ steps or $12$ hours. For our big models,(described on the bottom line of table $3$), step time was $1.0$ seconds. The big models were trained for $300,000$ steps ($3.5$ days).",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "3a8dc153-4a94-40f8-af6c-c7e70c29c246",
                    "title": "Optimizer",
                    "texts": "We used the Adam optimizer with $\\\\beta_1 = 0.9$, $\\\\beta_2 = 0.98$ and $\\\\epsilon = 10^{-9}$. We varied the learning rate over the course of training, according to the formula: $lrate = d^{-0.5}_{model} \\\\cdot \\\\min(step_{num}^{-0.5}, step_{num} \\\\cdot warmup_{steps}^{-1.5})$. This corresponds to increasing the learning rate linearly for the first $warmup_{steps}$ training steps, and decreasing it thereafter proportionally to the inverse square root of the step number. We used $warmup_{steps} = 4000$.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "5314ec67-89bf-4764-a62c-b686af852b4a",
                    "title": "Regularization",
                    "texts": "We employ three types of regularization during training:\n\n1. Residual Dropout: We apply dropout $[33]$ to the output of each sub-layer, before it is added to the sub-layer input and normalized. In addition, we apply dropout to the sums of the embeddings and the positional encodings in both the encoder and decoder stacks. For the base model, we use a rate of $P_{\\text{drop}} = 0.1$.\n\n2. Label Smoothing: During training, we employed label smoothing of value $\\epsilon_{\\text{ls}} = 0.1$ $[36]$. This hurts perplexity, as the model learns to be more unsure, but improves accuracy and BLEU score.",
                    "sections": []
                }
            ]
        },
        {
            "flag": true,
            "id": "54f21048-6d63-4411-b3ea-7cc3b8d0fc40",
            "title": "Results",
            "texts": "",
            "sections": [
                {
                    "flag": true,
                    "id": "376910db-02e6-4c63-94b7-4d99e5a536fa",
                    "title": "Machine Translation",
                    "texts": "On the WMT 2014 English-to-German translation task, the big transformer model (Transformer (big)) in Table 2 outperforms the best previously reported models (including ensembles) by more than $2.0$ BLEU, establishing a new state-of-the-art BLEU score of $28.4$. The configuration of this model is listed in the bottom line of Table 3. Training took $3.5$ days on $8$ P100 GPUs. Even our base model surpasses all previously published models and ensembles, at a fraction of the training cost of any of the competitive models.\n\nOn the WMT 2014 English-to-French translation task, our big model achieves a BLEU score of $41.0$, outperforming all of the previously published single models, at less than $\\frac{1}{4}$ the training cost of the previous state-of-the-art model. The Transformer (big) model trained for English-to-French used dropout rate $P_{\\text{drop}} = 0.1$, instead of $0.3$.\n\nFor the base models, we used a single model obtained by averaging the last $5$ checkpoints, which were written at $10$-minute intervals. For the big models, we averaged the last $20$ checkpoints. We used beam search with a beam size of $4$ and length penalty $\\\\alpha = 0.6$ [38]. These hyperparameters were chosen after experimentation on the development set. We set the maximum output length during inference to input length $+ 50$, but terminate early when possible [38].\n\nTable 2 summarizes our results and compares our translation quality and training costs to other model architectures from the literature. We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision floating-point capacity of each GPU.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "7a9b47e2-4e03-47fc-8aec-492940ae91ab",
                    "title": "Model Variations",
                    "texts": "To evaluate the importance of different components of the Transformer, we varied our base model in different ways, measuring the change in performance on English-to-German translation on the development set, newstest2013. We used beam search as described in the previous section, but no checkpoint averaging. We present these results in Table 3.\n\nIn Table 3 rows (A), we vary the number of attention heads and the attention key and value dimensions, keeping the amount of computation constant, as described in Section 3.2.2. While single-head attention is $0.9$ BLEU worse than the best setting, quality also drops off with too many heads.\n\nIn Table 3 rows (B), we observe that reducing the attention key size $d_k$ hurts model quality. This suggests that determining compatibility is not easy and that a more sophisticated compatibility function than dot product may be beneficial. We further observe in rows (C) and (D) that, as expected, bigger models are better, and dropout is very helpful in avoiding over-fitting. In row (E) we replace our sinusoidal positional encoding with learned positional embeddings, and observe nearly identical results to the base model.",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "2e6f7c77-ac38-4204-a7fe-9d0e97c3f841",
                    "title": "English Constituency Parsing",
                    "texts": "To evaluate if the Transformer can generalize to other tasks we performed experiments on English constituency parsing. This task presents specific challenges: the output is subject to strong structural constraints and is significantly longer than the input. Furthermore, RNN sequence-to-sequence models have not been able to attain state-of-the-art results in small-data regimes. We trained a 4-layer transformer with $d_{\\text{model}} = 1024$ on the Wall Street Journal (WSJ) portion of the Penn Treebank, about 40K training sentences. We also trained it in a semi-supervised setting, using the larger high-confidence and BerkleyParser corpora from with approximately 17M sentences. We used a vocabulary of 16K tokens for the WSJ only setting and a vocabulary of 32K tokens for the semi-supervised setting.\n\nWe performed only a small number of experiments to select the dropout, both attention and residual (section 5.4), learning rates and beam size on the Section 22 development set, all other parameters remained unchanged from the English-to-German base translation model. During inference, we increased the maximum output length to input length + 300. We used a beam size of 21 and $\\\\alpha = 0.3$ for both WSJ only and the semi-supervised setting.\n\nOur results in Table 4 show that despite the lack of task-specific tuning our model performs surprisingly well, yielding better results than all previously reported models with the exception of the Recurrent Neural Network Grammar. In contrast to RNN sequence-to-sequence models, the Transformer outperforms the BerkeleyParser even when training only on the WSJ training set of 40K sentences.",
                    "sections": []
                }
            ]
        },
        {
            "flag": true,
            "id": "7feb6a67-87ba-4c5a-90bb-b944ba12823c",
            "title": "Conclusion",
            "texts": "In this work, we presented the Transformer, the first sequence transduction model based entirely on attention, replacing the recurrent layers most commonly used in encoder-decoder architectures with multi-headed self-attention.\nFor translation tasks, the Transformer can be trained significantly faster than architectures based on recurrent or convolutional layers. On both WMT 2014 English-to-German and WMT 2014 English-to-French translation tasks, we achieve a new state of the art. In the former task our best model outperforms even all previously reported ensembles.\nWe are excited about the future of attention-based models and plan to apply them to other tasks. We plan to extend the Transformer to problems involving input and output modalities other than text and to investigate local, restricted attention mechanisms to efficiently handle large inputs and outputs such as images, audio and video. Making generation less sequential is another research goal of ours.\nThe code we used to train and evaluate our models is available at $https://github.com/tensorflow/tensor2tensor$.\nAcknowledgements We are grateful to Nal Kalchbrenner and Stephan Gouws for their fruitful comments, corrections and inspiration.",
            "sections": []
        }
    ],
    "summary": "本论文介绍了一种基于注意力机制的新型网络架构Transformer，完全基于注意力机制，摒弃了复杂的循环神经网络和卷积神经网络。实验证明，Transformer在机器翻译任务上表现优异，质量更高、可并行化且训练时间显著缩短。该模型在WMT 2014英德翻译任务上达到28.4 BLEU，优于现有最佳结果；在WMT 2014英法翻译任务上，单模型BLEU得分达到41.8，训练时间仅为3.5天。Transformer还成功应用于英语成分解析任务。论文通过比较自注意力层与常用的循环和卷积层，阐述了自注意力层的优势，包括计算复杂度、可并行化程度和网络中长距离依赖的路径长度。",
    "section_summaries": {
        "0": "介绍了Transformer模型，基于注意力机制，取代了循环和卷积层，在机器翻译任务上表现优异。",
        "1": "对循环神经网络和卷积神经网络在序列建模和转换问题中的应用进行了介绍，指出了传统模型的局限性。",
        "2": "介绍了Extended Neural GPU、ByteNet和ConvS2S等模型，讨论了Transformer相对于这些模型的优势。",
        "3": "详细描述了Transformer的模型架构，包括编码器和解码器堆叠、注意力机制、前馈网络、嵌入和Softmax、位置编码等。",
        "3.1": "介绍了编码器和解码器堆叠的结构。",
        "3.2": "详细介绍了注意力机制，包括缩放点积注意力和多头注意力。",
        "3.2.1": "介绍了缩放点积注意力的计算方法。",
        "3.2.2": "讨论了多头注意力的优势和应用。",
        "3.2.3": "描述了Transformer中注意力的不同应用方式。",
        "3.3": "介绍了位置逐位置的前馈网络。",
        "3.4": "描述了嵌入和Softmax的使用。",
        "3.5": "介绍了位置编码的方法，以便模型利用序列的顺序信息。",
        "4": "比较了自注意力层与常用的循环和卷积层在序列转换中的优劣。",
        "5": "描述了模型的训练过程，包括训练数据、硬件配置、优化器和正则化方法。",
        "5.1": "介绍了训练数据和批处理方法。",
        "5.2": "描述了硬件配置和训练进度。",
        "5.3": "介绍了优化器的选择和学习率调整方法。",
        "5.4": "讨论了训练过程中的正则化方法，包括残差丢弃和标签平滑。",
        "6": "展示了模型在机器翻译和英语成分解析任务上的结果，以及对模型变体的评估。",
        "6.1": "介绍了机器翻译任务的结果，包括BLEU分数和训练成本的比较。",
        "6.2": "评估了Transformer不同组件的重要性对模型性能的影响。",
        "6.3": "展示了模型在英语成分解析任务上的表现，证明Transformer的泛化能力。",
        "7": "总结了论文提出的Transformer模型，强调了其在机器翻译任务上的优越性，并展望了基于注意力机制的模型在其他任务上的应用。"
    },
    "overall_assessment": {
        "research_topic": "Transformer模型基于注意力机制，取代了传统的循环和卷积层，在机器翻译和英语成分解析任务中表现优异。",
        "research_outcomes": "论文提出的Transformer模型在机器翻译任务上取得了新的state-of-the-art结果，同时在英语成分解析任务中也表现出色。",
        "dataset_description": "",
        "methodology": "Transformer模型采用注意力机制，摒弃了循环和卷积层，实现了更高的并行性和更短的训练时间。",
        "innovations": "创新点在于完全基于注意力机制的Transformer模型，取得了优异的翻译质量和泛化能力。",
        "conclusions": "论文全面介绍了Transformer模型的结构、训练过程和实验结果，强调了其在机器翻译任务中的优越性，并展望了未来的研究方向。"
    },
    "zh_title-area": "注意力即一切",
    "zh_institutes-area": "Google Brain，Google Research，多伦多大学",
    "zh_introduction_processed": "循环神经网络，长短期记忆和门控循环神经网络特别是，在序列建模和转导问题（如语言建模和机器翻译）中，已经被牢固地确立为最先进的方法。此后，许多努力继续推动循环语言模型和编码器-解码器架构的边界。循环模型通常沿着输入和输出序列的符号位置因子化计算。将位置与计算时间步骤对齐，它们生成一系列隐藏状态 $h_t$，作为前一个隐藏状态 $h_{t-1}$ 和位置 $t$ 的输入的函数。这种固有的顺序性质排除了在训练示例内的并行化，这在较长的序列长度时变得至关重要，因为内存限制限制了跨示例的批处理。最近的工作通过因子化技巧和条件计算取得了计算效率方面的显著改进，同时在后者的情况下也提高了模型性能。然而，顺序计算的基本约束仍然存在。注意机制已经成为各种任务中引人注目的序列建模和转导模型的一个组成部分，允许对依赖关系进行建模，而不考虑它们在输入或输出序列中的距离。然而，在少数情况下，这种注意机制与循环网络一起使用。在这项工作中，我们提出了Transformer，这是一种模型架构，摒弃了循环，而是完全依赖于注意机制来绘制输入和输出之间的全局依赖关系。Transformer允许更多的并行化，并且在仅经过在八个P100 GPU上训练十二小时后，就可以达到新的翻译质量的最先进水平。",
    "zh_abstract_processed": "主导的序列转换模型基于复杂的递归或卷积神经网络，包括编码器和解码器。表现最佳的模型还通过注意机制连接编码器和解码器。我们提出了一种新的简单网络架构，即Transformer，仅基于注意机制，完全摒弃了递归和卷积。在两个机器翻译任务上的实验表明，这些模型在质量上优于其他模型，同时更易于并行化，并且需要显著较少的训练时间。我们的模型在WMT 2014英语到德语的翻译任务上实现了28.4 BLEU的分数，在现有的最佳结果基础上提高了超过2个BLEU，包括集成模型。在WMT 2014英语到法语的翻译任务上，我们的模型在8个GPU上训练3.5天后，实现了新的单模型最先进的BLEU分数为41.8，训练成本仅为文献中最佳模型的一小部分。我们证明Transformer对其他任务具有很好的泛化能力，成功地将其应用于使用大量和有限训练数据的英语成分解析。",
    "zh_keywords-area": "",
    "zh_sections_processed": [
        {
            "flag": true,
            "id": "d2d6bf28-9c68-4b74-be87-7a7415921680",
            "title": "背景",
            "texts": "减少顺序计算的目标也构成了Extended Neural GPU（EN-GPU）[16]、ByteNet[18]和ConvS2S的基础，所有这些模型都使用卷积神经网络作为基本构件，在所有输入和输出位置上并行计算隐藏表示。在这些模型中，两个任意输入或输出位置之间关联信号所需的操作数量随着位置之间的距离而增长，对于ConvS2S是线性增长，对于ByteNet是对数增长。这使得学习远距离位置之间的依赖关系变得更加困难。在Transformer中，这被减少到一个常数操作数，尽管由于对注意力加权位置进行平均而导致有效分辨率降低，我们在第3.2节中使用Multi-Head Attention来抵消这种影响。\n\n自注意力，有时称为内部注意力，是一种注意机制，用于关联单个序列的不同位置以计算序列的表示。自注意力已成功用于各种任务，包括阅读理解、抽象总结、文本蕴涵和学习任务无关的句子表示。\n\n端到端记忆网络基于循环注意机制，而不是序列对齐的循环，并且已经显示出在简单语言问答和语言建模任务上表现良好。\n\n据我们所知，然而，Transformer是第一个完全依赖自注意力来计算其输入和输出表示的传导模型，而不使用序列对齐的RNN或卷积。在接下来的几节中，我们将描述Transformer，激发自注意力并讨论其优点，与ByteNet和ConvS2S等模型相比。",
            "sections": []
        },
        {
            "flag": true,
            "id": "12ec6ed0-f7ff-403a-b61c-73174b2e81a7",
            "title": "模型架构",
            "texts": "大多数竞争性神经序列转导模型具有编码器-解码器结构。在这里，编码器将一个符号表示的输入序列$(x_1, ..., x_n)$映射到一个连续表示的序列$z = (z_1, ..., z_n)$。给定$z$，解码器然后逐个元素地生成一个符号输出序列$(y_1, ..., y_m)$。在每一步中，模型是自回归的，当生成下一个符号时，它会消耗先前生成的符号作为额外输入。",
            "sections": [
                {
                    "flag": true,
                    "id": "fc8a6d85-403f-4551-99f8-81b756e9bd5d",
                    "title": "编码器和解码器堆栈",
                    "texts": "编码器：编码器由 $N = 6$ 个相同的层堆叠而成。每个层包含两个子层。第一个是多头自注意力机制，第二个是简单的位置逐点全连接前馈网络。我们在每个子层周围使用了残差连接，然后进行层归一化。也就是说，每个子层的输出是 $\\text{LayerNorm}(x + \\text{Sublayer}(x))$，其中 $\\text{Sublayer}(x)$ 是子层自身实现的函数。为了促进这些残差连接，模型中的所有子层以及嵌入层产生维度为 $d_{\\text{model}} = 512$ 的输出。\n解码器：解码器也由 $N = 6$ 个相同的层堆叠而成。除了每个编码器层中的两个子层外，解码器还插入了第三个子层，该子层对编码器堆栈的输出执行多头注意力。与编码器类似，我们在每个子层周围使用残差连接，然后进行层归一化。我们还修改了解码器堆栈中的自注意力子层，以防止位置注意到后续位置。这种掩码结合输出嵌入向后偏移一个位置的事实，确保位置 $i$ 的预测仅取决于小于 $i$ 位置的已知输出。",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "b3e608c0-fb3d-49f2-a553-4e93da694334",
                    "title": "注意",
                    "texts": "一个注意力函数可以被描述为将一个查询和一组键-值对映射到一个输出，其中查询、键、值和输出都是向量。输出被计算为值的加权和，其中分配给每个值的权重由查询与相应键的兼容性函数计算。",
                    "sections": [
                        {
                            "flag": true,
                            "id": "dfd8bf32-e2b8-45bf-867e-6701c9d1295e",
                            "title": "缩放点积注意力",
                            "texts": "我们将我们特别关注的注意力称为“缩放点积注意力”（图2）。输入由维度为$d_k$的查询和键以及维度为$d_v$的值组成。我们计算查询与所有键的点积，将每个除以$\\\\sqrt{d_k}$，并应用softmax函数以获得值的权重。\n在实践中，我们同时对一组查询进行注意力函数计算，打包到一个矩阵$Q$中。键和值也打包到矩阵$K$和$V$中。我们计算输出矩阵如下：\n$$\\text{Attention}(Q, K, V) = \\text{softmax}(\\frac{QK}{\\sqrt{d_k}})V$$\n最常用的两种注意力函数是加性注意力和点积（乘法）注意力。点积注意力与我们的算法相同，只是缩放因子为$\\\\sqrt{1/d_k}$。加性注意力使用具有单个隐藏层的前馈网络计算兼容性函数。虽然在理论复杂性上两者相似，但在实践中，点积注意力更快速、更节省空间，因为可以使用高度优化的矩阵乘法代码实现。\n对于较小的$d_k$值，这两种机制表现类似，但对于较大的$d_k$值，加性注意力优于未经缩放的点积注意力。我们怀疑对于较大的$d_k$值，点积的结果会变得很大，将softmax函数推入具有极小梯度的区域。为了抵消这种影响，我们通过$\\\\sqrt{1/d_k}$来缩放点积。",
                            "sections": []
                        },
                        {
                            "flag": true,
                            "id": "d253c4b2-38ff-4706-b2b3-62544fe834fe",
                            "title": "多头注意力",
                            "texts": "我们发现，与具有$d_{\\text{model}}$维键、值和查询的单个注意力函数相比，通过使用不同的、学习到的线性投影将查询、键和值投影到$dk$、$dk$和$dv$维度，我们发现这样做是有益的。在这些投影版本的查询、键和值上，我们并行执行注意力函数，产生$dv$维输出值。然后将这些值进行串联，再次投影，得到最终值，如图2所示。\n多头注意力允许模型同时关注不同位置的不同表示子空间中的信息。使用单个注意力头，平均会抑制这一点。\n$MultiHead(Q, K, V) = \\text{Concat}(head_1, ..., head_h)WO$，其中$head_i = \\text{Attention}(QW_i^Q, KW_i^K, VW_i^V)$\n这里的投影是参数矩阵$W_i^Q \\in \\mathbb{R}^{d_{\\text{model}} \\times d_k}$，$W_i^K \\in \\mathbb{R}^{d_{\\text{model}} \\times d_k}$，$W_i^V \\in \\mathbb{R}^{d_{\\text{model}} \\times d_v}$和$W_O \\in \\mathbb{R}^{h \\times d_v \\times d_{\\text{model}}}$。在这项工作中，我们使用$h = 8$个并行注意力层或头。对于每个注意力头，我们使用$dk = dv = d_{\\text{model}}/h = 64$。由于每个头的降维，总计算成本与具有完整维度的单头注意力相似。",
                            "sections": []
                        },
                        {
                            "flag": true,
                            "id": "150706c0-4671-40c0-9ac7-40d6f6ff6bd9",
                            "title": "我们模型中注意力的应用包括：\n1. 自然语言处理：在机器翻译、文本摘要、问答系统等任务中，通过注意力机制可以有效捕捉输入序列中的重要信息。\n2. 计算机视觉：在图像分类、目标检测、图像生成等任务中，注意力机制可以帮助模型集中关注图像中的特定区域，从而提高模型性能。\n3. 强化学习：在智能体与环境交互的过程中，注意力机制可以用于选择动作或者关注环境中的重要部分，从而优化智能体的决策过程。\n4. 语音识别：在语音识别任务中，注意力机制可以帮助模型聚焦于输入音频中的关键片段，提高识别准确率。",
                            "texts": "Transformer 在三种不同的方式中使用多头注意力：\n• 在“编码器-解码器注意力”层中，查询来自前一个解码器层，而记忆键和值来自编码器的输出。这使得解码器中的每个位置都可以关注输入序列中的所有位置。这模仿了序列到序列模型中的典型编码器-解码器注意力机制，如$[38, 2, 9]$。\n• 编码器包含自注意力层。在自注意力层中，所有的键、值和查询都来自同一个地方，即编码器中前一层的输出。编码器中的每个位置都可以关注编码器前一层的所有位置。\n• 类似地，解码器中的自注意力层允许解码器中的每个位置关注解码器中直到该位置的所有位置。我们需要防止解码器中的左向信息流以保持自回归属性。我们通过在缩放的点积注意力中屏蔽（设置为$-∞$）与非法连接对应的softmax输入中的所有值来实现这一点。请参见图2。",
                            "sections": []
                        }
                    ]
                },
                {
                    "flag": true,
                    "id": "6ae9eedf-e5fa-4161-8adf-a0830833084d",
                    "title": "位置逐层前馈网络",
                    "texts": "除了注意力子层外，我们的编码器和解码器的每一层都包含一个完全连接的前馈网络，该网络分别且相同地应用于每个位置。这包括两个线性变换，中间有一个ReLU激活。\n$$FFN(x) = \\max(0, xW1 + b1)W2 + b2$$\n虽然线性变换在不同位置上是相同的，但它们在不同层之间使用不同的参数。另一种描述方式是将其描述为具有核大小1的两个卷积。输入和输出的维度为$d_{\\text{model}} = 512$，内部层的维度为$d_{\\text{ff}} = 2048$。",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "01ef2da7-d53f-435a-89ec-5626cfa7adb6",
                    "title": "嵌入和Softmax",
                    "texts": "与其他序列转导模型类似，我们使用学习到的嵌入将输入标记和输出标记转换为维度为$d_{\\text{model}}$的向量。我们还使用通常的学习线性转换和softmax函数将解码器输出转换为预测的下一个标记概率。在我们的模型中，我们在两个嵌入层和预softmax线性变换之间共享相同的权重矩阵，类似于[30]。在嵌入层中，我们将这些权重乘以$\\\\sqrt{d_{\\text{model}}}$。",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "499cfaf8-be29-409d-a9d4-0ed0010ccb24",
                    "title": "位置编码",
                    "texts": "由于我们的模型不包含循环和卷积，为了使模型利用序列的顺序，我们必须注入关于序列中标记的相对或绝对位置的一些信息。\n为此，我们在编码器和解码器堆栈的底部向输入嵌入添加'位置编码'。位置编码与嵌入具有相同的维度$d_{\\text{model}}$，以便两者可以相加。有许多选择的位置编码，包括学习和固定。\n在这项工作中，我们使用不同频率的正弦和余弦函数：\n$PE(pos,2i) = \\sin(pos / 10000^{2i} / d_{\\text{model}})$\n$PE(pos,2i+1) = \\cos(pos / 10000^{2i} / d_{\\text{model}})$\n其中pos是位置，i是维度。也就是说，位置编码的每个维度对应一个正弦波。波长从$2\\pi$到$10000 \\cdot 2\\pi$形成几何级数。我们选择这个函数，因为我们假设它将使模型能够轻松学习通过相对位置进行关注，因为对于任何固定的偏移k，$PE_{pos+k}$可以表示为$PE_{pos}$的线性函数。\n我们还尝试使用学习的位置嵌入，发现两个版本产生的结果几乎相同。我们选择了正弦版本，因为它可能使模型能够推广到比训练过程中遇到的序列长度更长的情况。",
                    "sections": []
                }
            ]
        },
        {
            "flag": true,
            "id": "9a320189-5397-4731-b125-0832b9962cd2",
            "title": "为什么自注意力",
            "texts": "在本节中，我们将自注意力层的各个方面与常用于将一个变长符号表示序列$(x_1, ..., x_n)$映射到另一个相等长度序列$(z_1, ..., z_n)$的循环和卷积层进行比较，其中$x_i, z_i \\in \\mathbb{R}^d$，例如典型序列转导编码器或解码器中的隐藏层。在激发我们使用自注意力的动机时，我们考虑了三个期望。其中一个是每层的总计算复杂度。另一个是可以并行计算的量，由所需的最小顺序操作数来衡量。第三个是网络中长程依赖之间的路径长度。学习长程依赖是许多序列转导任务中的一个关键挑战。影响学习这种依赖能力的一个关键因素是前向和后向信号在网络中必须穿过的路径长度。在输入和输出序列的任意位置组合之间的路径越短，学习长程依赖就越容易。因此，我们还比较了由不同层类型组成的网络中任意两个输入和输出位置之间的最大路径长度。正如表1所示，自注意力层连接所有位置需要恒定数量的顺序执行操作，而循环层则需要$O(n)$个顺序操作。就计算复杂度而言，当序列时，自注意力层比循环层更快",
            "sections": []
        },
        {
            "flag": true,
            "id": "651fe7c7-d25e-4ad9-87db-7136b645ff5c",
            "title": "训练",
            "texts": "本节描述了我们模型的训练方案。",
            "sections": [
                {
                    "flag": true,
                    "id": "2bcc9650-c262-4e90-918a-e45846ba47c2",
                    "title": "训练数据和分批处理",
                    "texts": "我们在标准的WMT 2014英德数据集上进行了训练，该数据集包含大约450万个句对。句子是使用字节对编码（$[3]$）进行编码的，其中共享源-目标词汇量约为37000个标记。\n\n对于英法语言对，我们使用了规模显着较大的WMT 2014英法数据集，其中包含了3600万个句子，并将标记拆分为一个32000个单词片段的词汇表（$[38]$）。句子对是根据近似的序列长度一起批处理的。每个训练批次包含一组句对，其中大约包含25000个源标记和25000个目标标记。",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "ce1fdeda-e1b8-45ec-a0ae-084e29586e7c",
                    "title": "硬件和时间表",
                    "texts": "我们在一台配备8个NVIDIA P100 GPU的机器上训练了我们的模型。对于使用本文中描述的超参数的基础模型，每个训练步骤大约需要$0.4$秒。我们总共训练了$100,000$步或$12$小时。对于我们的大型模型（表$3$底部一行所描述的），每步时间为$1.0$秒。这些大型模型被训练了$300,000$步（$3.5$天）。",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "3a8dc153-4a94-40f8-af6c-c7e70c29c246",
                    "title": "优化器",
                    "texts": "我们使用了Adam优化器，其中$\\\\beta_1 = 0.9$，$\\\\beta_2 = 0.98$，$\\\\epsilon = 10^{-9}$。我们根据以下公式在训练过程中改变学习率：$lrate = d^{-0.5}_{model} \\\\cdot \\\\min(step_{num}^{-0.5}, step_{num} \\\\cdot warmup_{steps}^{-1.5})$。这意味着在前$warmup_{steps}$个训练步骤中线性增加学习率，之后按照步数的倒数平方根成比例地减少。我们使用了$warmup_{steps} = 4000$。",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "5314ec67-89bf-4764-a62c-b686af852b4a",
                    "title": "正则化",
                    "texts": "我们在训练过程中采用了三种类型的正则化:\n\n1. 残差丢弃: 我们在每个子层的输出上应用了辍学$[33]$, 在它被添加到子层输入并进行规范化之前。此外, 我们在编码器和解码器堆栈中的嵌入和位置编码的总和上也应用了辍学。对于基础模型, 我们使用了$P_{\\text{drop}} = 0.1$的速率。\n\n2. 标签平滑: 在训练过程中, 我们采用了值为$\\epsilon_{\\text{ls}} = 0.1$的标签平滑$[36]$。这会损害困惑度, 因为模型学会更不确定, 但会提高准确性和BLEU分数。",
                    "sections": []
                }
            ]
        },
        {
            "flag": true,
            "id": "54f21048-6d63-4411-b3ea-7cc3b8d0fc40",
            "title": "结果",
            "texts": "",
            "sections": [
                {
                    "flag": true,
                    "id": "376910db-02e6-4c63-94b7-4d99e5a536fa",
                    "title": "机器翻译",
                    "texts": "在WMT 2014年的英德翻译任务中，大型变压器模型（表2中的Transformer（big））的表现优于之前报道的最佳模型（包括集成模型）超过$2.0$ BLEU，建立了新的BLEU得分记录，达到了$28.4$。该模型的配置列在表3的底部行。训练在$8$个P100 GPU上花费了$3.5$天。甚至我们的基础模型也超过了以前发布的所有模型和集成模型，在任何竞争模型的训练成本的一小部分内。\n\n在WMT 2014年的英法翻译任务中，我们的大型模型实现了$41.0$的BLEU得分，在训练成本不到之前最先进模型的$\\frac{1}{4}$的情况下，优于所有先前发布的单一模型。英法翻译中训练的Transformer（big）模型使用了$P_{\\text{drop}} = 0.1$的dropout率，而不是$0.3$。\n\n对于基础模型，我们使用了通过平均最后$5$个检查点获得的单一模型，这些检查点是在$10$分钟间隔内编写的。对于大型模型，我们平均了最后$20$个检查点。我们使用了束搜索，束大小为$4$，长度惩罚$\\\\alpha = 0.6$ [38]。这些超参数是在开发集上进行实验后选择的。在推断期间，我们将最大输出长度设置为输入长度$+ 50$，但尽可能提前终止[38]。\n\n表2总结了我们的结果，并将我们的翻译质量和训练成本与文献中的其他模型架构进行了比较。我们通过将训练时间、使用的GPU数量和每个GPU的持续单精度浮点容量的估计相乘来估算训练模型所使用的浮点运算次数。",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "7a9b47e2-4e03-47fc-8aec-492940ae91ab",
                    "title": "模型变化",
                    "texts": "为了评估Transformer不同组件的重要性，我们以不同的方式改变了我们的基础模型，在英语到德语翻译的开发集newstest2013上测量了性能变化。我们使用了前一节中描述的beam search，但没有使用检查点平均。我们在表3中呈现了这些结果。\n\n在表3的行(A)中，我们变化了注意力头的数量以及注意力键和值的维度，保持计算量恒定，如3.2.2节所述。虽然单头注意力比最佳设置差了$0.9$ BLEU，但质量也随着头数过多而下降。\n\n在表3的行(B)中，我们观察到减少注意力键的大小$d_k$会降低模型质量。这表明确定兼容性并不容易，而比点积更复杂的兼容性函数可能是有益的。我们进一步观察到在行(C)和(D)中，更大的模型更好，并且辍学在避免过拟合方面非常有帮助。在行(E)中，我们用学习得到的位置嵌入替换了我们的正弦位置编码，并观察到与基础模型几乎相同的结果。",
                    "sections": []
                },
                {
                    "flag": true,
                    "id": "2e6f7c77-ac38-4204-a7fe-9d0e97c3f841",
                    "title": "英语成分句法分析",
                    "texts": "为了评估Transformer是否能推广到其他任务，我们对英语成分句法分析进行了实验。这项任务提出了具体的挑战：输出受到强烈的结构约束，并且比输入长得多。此外，RNN序列到序列模型在小数据情况下无法达到最先进的结果。我们在Penn Treebank的华尔街日报（WSJ）部分上训练了一个4层的Transformer，大约有40K个训练句子。我们还在半监督设置中对其进行了训练，使用了约1700万个句子的更大的高置信度和BerkleyParser语料库。我们在WSJ单独设置中使用了16K个标记的词汇表，在半监督设置中使用了32K个标记的词汇表。\n\n我们只进行了少量实验来选择dropout，注意力和残差（第5.4节），学习率和beam大小在第22节开发集上，所有其他参数保持不变来自英语到德语的基本翻译模型。在推断期间，我们将最大输出长度增加到输入长度+300。我们在WSJ单独和半监督设置中都使用了beam大小为21和$\\\\alpha = 0.3$。\n\n我们的结果在表4中显示，尽管缺乏任务特定的调整，我们的模型表现得出奇地好，产生的结果比以前报告的所有模型都要好，除了递归神经网络语法。与RNN序列到序列模型相比，Transformer甚至在仅在40K个句子的WSJ训练集上训练时也优于BerkleyParser。",
                    "sections": []
                }
            ]
        },
        {
            "flag": true,
            "id": "7feb6a67-87ba-4c5a-90bb-b944ba12823c",
            "title": "结论",
            "texts": "在这项工作中，我们提出了 Transformer，这是第一个完全基于注意力的序列转导模型，用多头自注意力替换了编码器-解码器体系结构中最常用的循环层。\n对于翻译任务，Transformer 的训练速度显著快于基于循环或卷积层的架构。在 WMT 2014 英语到德语和 WMT 2014 英语到法语的翻译任务上，我们取得了新的最先进水平。在前一项任务中，我们的最佳模型甚至优于先前报告的所有合奏。\n我们对基于注意力的模型的未来感到兴奋，并计划将它们应用于其他任务。我们计划将 Transformer 扩展到涉及文本以外的输入和输出模态的问题，并研究局部、受限制的注意力机制，以有效处理大型输入和输出，如图像、音频和视频。使生成 less sequential 是我们的另一个研究目标。\n我们用于训练和评估我们的模型的代码可在 $https://github.com/tensorflow/tensor2tensor$ 上找到。\n致谢我们感谢 Nal Kalchbrenner 和 Stephan Gouws 对他们的有益评论、更正和启发。",
            "sections": []
        }
    ],
    "introduction-area": "Recurrent neural networks, long short-term memory [13] and gated recurrent [7] neural networks\nin particular, have been firmly established as state of the art approaches in sequence modeling and\ntransduction problems such as language modeling and machine translation [35, 2, 5]. Numerous\nefforts have since continued to push the boundaries of recurrent language models and encoder-decoder\narchitectures [38, 24, 15].\nRecurrent models typically factor computation along the symbol positions of the input and output\nsequences. Aligning the positions to steps in computation time, they generate a sequence of hidden\nstates ht, as a function of the previous hidden state ht−1 and the input for position t. This inherently\nsequential nature precludes parallelization within training examples, which becomes critical at longer\nsequence lengths, as memory constraints limit batching across examples. Recent work has achieved\nsignificant improvements in computational efficiency through factorization tricks [21] and conditional\ncomputation [32], while also improving model performance in case of the latter. The fundamental\nconstraint of sequential computation, however, remains.\nAttention mechanisms have become an integral part of compelling sequence modeling and transduction models in various tasks, allowing modeling of dependencies without regard to their distance in\nthe input or output sequences [2, 19]. In all but a few cases [27], however, such attention mechanisms\nare used in conjunction with a recurrent network.\nIn this work we propose the Transformer, a model architecture eschewing recurrence and instead\nrelying entirely on an attention mechanism to draw global dependencies between input and output.\nThe Transformer allows for significantly more parallelization and can reach a new state of the art in\ntranslation quality after being trained for as little as twelve hours on eight P100 GPUs.",
    "abstract-area": "The dominant sequence transduction models are based on complex recurrent or\nconvolutional neural networks that include an encoder and a decoder. The best\nperforming models also connect the encoder and decoder through an attention\nmechanism. We propose a new simple network architecture, the Transformer,\nbased solely on attention mechanisms, dispensing with recurrence and convolutions\nentirely. Experiments on two machine translation tasks show these models to\nbe superior in quality while being more parallelizable and requiring significantly\nless time to train. Our model achieves 28.4 BLEU on the WMT 2014 Englishto-German translation task, improving over the existing best results, including\nensembles, by over 2 BLEU. On the WMT 2014 English-to-French translation task,\nour model establishes a new single-model state-of-the-art BLEU score of 41.8 after\ntraining for 3.5 days on eight GPUs, a small fraction of the training costs of the\nbest models from the literature. We show that the Transformer generalizes well to\nother tasks by applying it successfully to English constituency parsing both with\nlarge and limited training data."
}